# AKARI-UDP v3 計画書

## ゴール
- チャンク数×40B（ヘッダ24B + タグ16B）の固定オーバヘッドを大幅削減し、現状（例: 69チャンクで約2.7KB）から **最大約80%削減** を目指す。
- ヘッダ可変長・ヘッダ分割対応で大きなレスポンスも安全に運べる。
- 後方互換: v2 非対応リモートにはフォールバック可能。

## 改善見込み（オーバヘッド試算）
| ケース | チャンク数 | v2 オーバヘッド (40B/チャンク) | v3 短ヘッダ+集約タグ案 | 削減率 |
|--------|------------|--------------------------------|------------------------|--------|
| 70KBレスポンス, 1350Bチャンク相当 (69チャンク) | 69 | 約2,760B | 先頭26B + 後続68×6B ≒ **442B** | **約84%削減** |
| 20KBレスポンス, 1350Bチャンク相当 (16チャンク) | 16 | 640B | 先頭26B + 15×6B ≒ **116B** | 約82%削減 |
| 5KBレスポンス, 1350Bチャンク相当 (4チャンク)  | 4  | 160B | 先頭26B + 3×6B ≒ **44B**  | 約72%削減 |
※ 集約タグ(16B)を先頭または末尾に1回だけ付ける想定。ヘッダ分割が発生する場合は + (ヘッダ継続数×短ヘッダ) 程度。

## パケット種別（v3 案）
```
共通: Magic "AK" | ver=0x03 | type | flags | msg_id(16/64) | ...

[Req]
  type=req
  payload: method | url_len | url | opt_hdr_block

[Resp-Head]  (ヘッダ先頭)
  type=resp-head
  fields: status | hdr_len | body_len | hdr_chunks | hdr_idx=0 | seq_total(body) | flags
  payload: header_slice(可変)

[Resp-Head-Cont]  (ヘッダ継続がある場合のみ)
  type=resp-head-cont
  fields: hdr_idx
  payload: header_slice

[Resp-Body]  (本文チャンク)
  type=resp-body
  fields: body_seq
  payload: body_chunk

[NACK-BODY]
  type=nack-body
  fields: first_missing or bitmap (短縮)

[NACK-HEAD]
  type=nack-head
  fields: missing_hdr_idx bitmap（ヘッダチャンク欠損通知）

[ACK] (必要なら)
  type=ack
  fields: first_missing
```

### フラグ案
- 0x80: encrypt
- 0x40: aggregate-tag（まとめて1タグ）
- 0x20: short-id (16bit msg_id)
- 0x10: short-len (3B body_len / hdr_len)
- 0x08: hdr-continues（ヘッダ継続があることを示す）

## フロー概要（視覚イメージ）
```
Client                          Remote
  | -- Req --------------------> |
  | < Resp-Head (hdr_idx=0) ---- |
  | < Resp-Head-Cont ... (opt) - |
  | < Resp-Body(seq=0..n) ------ |
  |          [欠損時 NACK-BODY / NACK-HEAD] |
  | < Resp-Body(retrans) ------- |
  | --- 完了/検証 --------------> |
```

## 受信側再構成アルゴリズム（簡略）
1. `message_id`キーで `{hdr_chunks{}, body_chunks{}}` を保持。
2. `Resp-Head`を受信したら `hdr_chunks` の総数 (`hdr_chunks`) を確定。`seq_total(body)` も記録。
3. 欠損ヘッダがあれば `NACK-HEAD` で再請求。完了後にヘッダブロックをデコード。
4. ボディ欠損は `NACK-BODY` で再請求。揃ったら連結。
5. 集約タグでヘッダ+ボディ塊をまとめて1回だけ認証検証。失敗時は再リクエスト。

## 実装ステップ（優先度順）
1. `HeaderV3` 定義と短縮ヘッダエンコード/デコード（msg_id 16/64bit切替、short-len対応）。
2. パケット種別追加（resp-head/resp-head-cont/resp-body/nack/ack）とフラグ定義。
3. 送信側（リモート）: 先頭ヘッダパケット生成、ヘッダ分割送信（必要時のみ）、ボディ短ヘッダ送信。
4. 受信側（ローカル）: v3優先デコード、欠損検知・NACK、集約タグ検証。
5. フォールバック: v3非対応応答なら v2 で再試行。
6. 計測: compare_data_volume.py に v3 オプションを追加し、オーバヘッド削減を確認。

## 留意点
- MTU内に収める（デフォルトペイロード上限 1200B）。DF/PLPMTUD の扱いは後述。
- レート制限は現状なし（実装簡素化）。必要になれば追加。
- ヘッダ圧縮はデフォルト有効（HPACK-lite/CBOR 想定）。秘密データ混在時は圧縮オフのフラグで明示的に無効化。
- 未知フラグは無視するルールを明記し、前方互換性を確保。

## 追加アイデア（優先導入する3点）
- **ヘッダ予約ラベル付きバッファ**: 受信側で `msg_id` ごとにヘッダ領域とボディ領域を分離保持。ヘッダ未着でもボディを捨てずキューし、ヘッダ到着後に再構成。メモリ上限と古いmsgの破棄ポリシーを設定。
- **ヘッダ圧縮＋冗長ビット（可能なら）**: ヘッダをCBOR/HPACK-lite等で圧縮し、`hdr_chunks`が複数になる場合は各継続フレームに短いサマリ（ハッシュや長さ）を重畳して欠損時の検出性を高める。圧縮オフのフラグも用意し秘密データ混在を避ける。
- **優先度付き再送**: 再送要求は「ヘッダ欠損が最優先、ボディ欠損はヘッダ完了後」にする。`NACK-HEAD` を優先送出し、ヘッダ完了までは `NACK-BODY` を抑制（もしくは遅延）することで無駄な往復を減らし、欠損範囲判定を安定させる。

## 運用パラメータ（現時点のデフォルト）
- タイムアウト: 10秒（メッセージ全体・ヘッダ待ち・ボディ待ちの基準。細分化しない簡易案）
- NACK送信: 欠損が改善している間は無制限。改善しない状態が2連続で起きたら破棄（メッセージを捨てて再リクエストへ）。
- 再リクエスト: 1回まで（それ以上はエラーにする）。
- メモリ上限: 無制限（実装単純化）。必要になれば上限と破棄ポリシーを導入。

## タグ方針（集約タグのみ）
- v3ではタグは「集約タグ」固定（1メッセージ1回）。分割タグ（per-packetタグ）は廃止。
- 非対応リモートに当たった場合は v2 へフォールバックして再試行（1回まで）。
- 受信側は未知フラグを無視するため、agg-tagフラグが立っていても理解できない場合はエラー/タイムアウトで検出し、送信側がv2再送に切り替える。

## DF / PLPMTUD の簡単な指針
- DF (Don't Fragment) を立てると経路上でIPフラグメントが発生せず、MTU超過パケットはICMP "Fragmentation Needed" で返る。安全だがICMPがブロックされる環境ではブラックホール化のリスク。
- PLPMTUD (Packetization Layer PMTU Discovery) はICMPに頼らず、サイズを変えたプローブを送って到達可否でMTUを探る手法。実装コストは上がるが、ICMP遮断環境でも有効。
- 現実的な初期値: ペイロード上限 1200B（QUICと同程度）。DFはONにするが、問題が出る環境向けに DF-OFF のオプションを用意しておく。

## 期待効果まとめ
- ボディパケットの固定オーバヘッドが 40B → 約6B（＋集約タグ1回）になり、チャンク数が多いレスポンスで顕著に効く。
- 小さいレスポンスでもヘッダパケット1回＋少数ボディで 70%前後削減。
- 再送パケットが短縮され、欠損時の余計な帯域消費も低減。
