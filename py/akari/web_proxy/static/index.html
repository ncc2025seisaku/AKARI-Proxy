<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Akari Web Proxy</title>
    <style>
      :root {
        color-scheme: dark;
        --text: #f6f2ea;
        --muted: rgba(246, 242, 234, 0.65);
        --accent: #f3c45c;
        font-family: "Inter", "SF Pro Display", "Yu Gothic", system-ui, sans-serif;
      }

      * {
        box-sizing: border-box;
      }

      body {
        min-height: 100vh;
        margin: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--text);
        text-rendering: optimizeLegibility;
        padding: 2rem;
        overflow: hidden;
        transition: background 0.25s ease;
        background-attachment: fixed;
        background: #0a0a0a;
      }

      body::before {
        content: "";
        position: fixed;
        inset: 0;
        background-image: url("logo.png");
        background-position: center;
        background-repeat: no-repeat;
        background-size: clamp(520px, 72vmin, 1024px);
        opacity: 0.24;
        filter: blur(1.5px);
        transform: translateY(-2%);
        pointer-events: none;
        transition: filter 0.25s ease, opacity 0.25s ease;
        z-index: -1;
      }

      body.focused::before {
        opacity: 0.12;
        filter: blur(8px);
      }

      main {
        position: relative;
        width: min(520px, 100%);
        max-width: 520px;
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1.3rem;
      }

      h1 {
        margin: 0 0 1.1rem;
        letter-spacing: 0.18rem;
        font-size: clamp(2.4rem, 3vw, 2.9rem);
      }

      .liquid-glass {
        width: min(460px, 90vw);
        border-radius: 56px;
        position: relative;
        isolation: isolate;
        display: flex;
        flex-direction: column;
        align-items: stretch;
        gap: 1.15rem;
        border: none;
        background: none;
        padding: 2.25rem 2.5rem 1.75rem;
        margin: 0 auto;
        text-decoration: none;
      }

      .input-area {
        width: 100%;
        display: flex;
        gap: 0.75rem;
        align-items: center;
        position: relative;
        padding: 0.9rem 1rem;
        border-radius: 26px;
        border: 1px solid rgba(255, 255, 255, 0.35);
        overflow: hidden;
        isolation: isolate;
      }

      .input-area canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
        pointer-events: none;
      }

      .input-area > input,
      .input-area > button {
        position: relative;
        z-index: 1;
      }

      .input-area input {
        flex: 1;
        border: 1px solid transparent;
        border-radius: 14px;
        background: rgba(0, 0, 0, 0.3);
        box-shadow: inset 0 0 14px rgba(0, 0, 0, 0.3);
        color: var(--text);
        font-size: 1.1rem;
        font-weight: 500;
        padding: 0.35rem 0.5rem;
        line-height: 1.6;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      }

      .input-area input::placeholder {
        color: rgba(246, 242, 234, 0.75);
      }

      .input-area input:focus-visible {
        border-color: rgba(243, 196, 92, 0.9);
        box-shadow: 0 0 0 2px rgba(243, 196, 92, 0.3);
        background: rgba(0, 0, 0, 0.4);
        outline: none;
      }

      .input-area button {
        border: none;
        border-radius: 14px;
        padding: 0.65rem 1.4rem;
        font-size: 0.95rem;
        font-weight: 600;
        letter-spacing: 0.05rem;
        background: linear-gradient(135deg, rgba(255, 216, 137, 0.95), rgba(191, 141, 41, 0.9));
        color: #08060a;
        cursor: pointer;
        transition: transform 0.18s ease, box-shadow 0.18s ease;
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.15), 0 10px 24px rgba(223, 140, 41, 0.45);
      }

      .input-area button:hover {
        transform: translateY(-1px);
        box-shadow: 0 16px 26px rgba(223, 140, 41, 0.55);
      }

      .input-area button:focus-visible {
        outline: none;
        box-shadow: 0 0 0 3px rgba(255, 209, 106, 0.45), 0 16px 26px rgba(223, 140, 41, 0.4);
      }

      body.focused .input-area {
        border-color: rgba(255, 255, 255, 0.6);
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        border: 0;
      }

      #sourceImage {
        display: none;
      }

      @media (max-width: 520px) {
        body {
          padding: 1.2rem;
        }

        .liquid-glass {
          padding: 1.6rem 1.4rem 1.2rem;
        }

        .input-area {
          flex-direction: column;
          gap: 0.65rem;
        }

        .input-area button {
          width: 100%;
          padding: 0.55rem 0;
        }

      }
    </style>
  </head>
  <body>
    <main>
      <div id="searchPanel" class="liquid-glass">
        <label class="sr-only" for="query">URL を入力してください</label>
        <div class="input-area">
          <canvas id="glassCanvas"></canvas>
          <input
            id="query"
            name="query"
            type="text"
            placeholder="URL を入力してください"
            autocomplete="off"
          />
          <button id="submitSearch" type="button">OPEN</button>
        </div>
      </div>
    </main>
    <img
      id="sourceImage"
      style="display: none;"
      alt=""
    />
    <script id="fragShader" type="x-shader/x-fragment">
      precision mediump float;

      uniform vec3 iResolution;
      uniform float iTime;
      uniform sampler2D iChannel0;

      void mainImage(out vec4 fragColor, in vec2 fragCoord)
      {
        const float NUM_ZERO = 0.0;
        const float NUM_ONE = 1.0;
        const float NUM_HALF = 0.5;
        const float LENS_STRENGTH = 0.012;
        const float SAMPLE_RANGE = 3.0;
        const float SAMPLE_OFFSET = 0.4;
        const float EDGE_FADE = 0.06;
        const float LIGHTING_INTENSITY = 0.18;

        vec2 uv = fragCoord / iResolution.xy;
        
        // エッジでフェードアウトする係数
        vec2 edgeDist = min(uv, NUM_ONE - uv);
        float edgeFactor = smoothstep(NUM_ZERO, EDGE_FADE, min(edgeDist.x, edgeDist.y));
        
        // 全体に屈折効果を適用
        vec2 center = vec2(NUM_HALF, NUM_HALF);
        vec2 toCenter = uv - center;
        
        // レンズ歪み（全体に適用）
        vec2 lens = uv + toCenter * LENS_STRENGTH * edgeFactor;
        
        // ブラー効果
        fragColor = vec4(NUM_ZERO);
        float total = NUM_ZERO;
        for (float x = -SAMPLE_RANGE; x <= SAMPLE_RANGE; x++) {
          for (float y = -SAMPLE_RANGE; y <= SAMPLE_RANGE; y++) {
            vec2 offset = vec2(x, y) * SAMPLE_OFFSET / iResolution.xy;
            fragColor += texture2D(iChannel0, offset + lens);
            total += NUM_ONE;
          }
        }
        fragColor /= total;
        
        // ライティング効果
        float gradient = smoothstep(-NUM_HALF, NUM_HALF, toCenter.y) * edgeFactor;
        fragColor += vec4(gradient * LIGHTING_INTENSITY) * edgeFactor;
      }

      void main() {
        mainImage(gl_FragColor, gl_FragCoord.xy);
      }
    </script>
    <script>
      const queryInput = document.getElementById("query");
      const searchButton = document.getElementById("submitSearch");
      const canvas = document.getElementById("glassCanvas");
      const inputArea = document.querySelector(".input-area");
      const img = document.getElementById("sourceImage");
      const gl = canvas.getContext("webgl");

      const updateFocusState = () => {
        const active = document.activeElement === queryInput || queryInput.value.trim().length > 0;
        document.body.classList.toggle("focused", active);
      };

      queryInput.addEventListener("focus", updateFocusState);
      queryInput.addEventListener("blur", updateFocusState);
      queryInput.addEventListener("input", updateFocusState);
      updateFocusState();

      const normalizeUrl = (text) => {
        if (/^[a-zA-Z][a-zA-Z0-9+.-]*:\/\//.test(text)) {
          return text;
        }
        if (text.includes(".")) {
          return `https://${text}`;
        }
        return text;
      };

      const openProxy = () => {
        const text = queryInput.value.trim();
        if (!text) {
          queryInput.focus();
          return;
        }
        const normalized = normalizeUrl(text);
        window.location.href = `/${normalized}`;
      };

      searchButton.addEventListener("click", openProxy);
      queryInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter" && !event.shiftKey) {
          event.preventDefault();
          openProxy();
        }
      });

      // WebGL Setup
      const captureBackground = () => {
        const rect = inputArea.getBoundingClientRect();
        const tempCanvas = document.createElement('canvas');
        const ctx = tempCanvas.getContext('2d');
        
        tempCanvas.width = rect.width;
        tempCanvas.height = rect.height;
        
        // 暗い背景色（ロゴと同じ色）
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
        
        // logo.png があれば描画
        const logoImg = new Image();
        logoImg.src = 'logo.png';
        logoImg.onload = () => {
          ctx.globalAlpha = 0.24;
          ctx.filter = 'blur(1.5px)';
          const logoSize = Math.min(rect.width, rect.height) * 0.8;
          ctx.drawImage(
            logoImg,
            (rect.width - logoSize) / 2,
            (rect.height - logoSize) / 2 - rect.height * 0.02,
            logoSize,
            logoSize
          );
          img.src = tempCanvas.toDataURL();
        };
        
        // ロゴ読み込み失敗時のフォールバック
        logoImg.onerror = () => {
          img.src = tempCanvas.toDataURL();
        };
        
        return tempCanvas;
      };

      const setCanvasSize = () => {
        const rect = inputArea.getBoundingClientRect();
        const width = Math.max(1, Math.floor(rect.width));
        const height = Math.max(1, Math.floor(rect.height));
        if (canvas.width !== width || canvas.height !== height) {
          canvas.width = width;
          canvas.height = height;
          
          // 背景を再キャプチャ
          const bgCanvas = captureBackground();
          img.src = bgCanvas.toDataURL();
        }
      };

      const adjustLayout = () => {
        setCanvasSize();
      };

      adjustLayout();
      window.addEventListener("resize", adjustLayout);

      if (!gl) {
        console.error("WebGL がサポートされていません。");
      } else {
        const vsSource = `
          attribute vec2 position;
          void main() {
            gl_Position = vec4(position, 0.0, 1.0);
          }
        `;
        const fsSource = document.getElementById("fragShader").textContent;

        const createShader = (type, source) => {
          const shader = gl.createShader(type);
          gl.shaderSource(shader, source);
          gl.compileShader(shader);

          if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error("Shader error:", gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
          }
          return shader;
        };

        const vs = createShader(gl.VERTEX_SHADER, vsSource);
        const fs = createShader(gl.FRAGMENT_SHADER, fsSource);
        const program = gl.createProgram();

        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        gl.useProgram(program);

        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]),
          gl.STATIC_DRAW
        );

        const position = gl.getAttribLocation(program, "position");
        gl.enableVertexAttribArray(position);
        gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);

        const uniforms = {
          resolution: gl.getUniformLocation(program, "iResolution"),
          time: gl.getUniformLocation(program, "iTime"),
          texture: gl.getUniformLocation(program, "iChannel0"),
        };

        const texture = gl.createTexture();
        
        let textureReady = false;
        const setupTexture = () => {
          if (img.src && img.complete) {
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(
              gl.TEXTURE_2D,
              0,
              gl.RGBA,
              gl.RGBA,
              gl.UNSIGNED_BYTE,
              img
            );
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            textureReady = true;
          }
        };

        img.onload = setupTexture;
        
        // 初期背景をキャプチャ
        const bgCanvas = captureBackground();
        img.src = bgCanvas.toDataURL();

        const startTime = performance.now();
        const render = () => {
          if (!textureReady) {
            requestAnimationFrame(render);
            return;
          }
          
          const currentTime = (performance.now() - startTime) / 1000;

          gl.viewport(0, 0, canvas.width, canvas.height);
          gl.clear(gl.COLOR_BUFFER_BIT);

          gl.uniform3f(uniforms.resolution, canvas.width, canvas.height, 1.0);
          gl.uniform1f(uniforms.time, currentTime);

          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.uniform1i(uniforms.texture, 0);

          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
          requestAnimationFrame(render);
        };

        render();
      }
    </script>
  </body>
</html>
