// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'akari_client.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `acquire`, `release`, `to_rust`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `from`, `from`

/// Create a default request configuration.
AkariRequestConfig defaultRequestConfig() =>
    RustLib.instance.api.crateApiAkariClientDefaultRequestConfig();

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AkariClient>>
abstract class AkariClient implements RustOpaqueInterface {
  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Create a new client connected to the remote proxy.
  static Future<AkariClient> newInstance({
    required String host,
    required int port,
    required List<int> psk,
  }) => RustLib.instance.api.crateApiAkariClientAkariClientNew(
    host: host,
    port: port,
    psk: psk,
  );

  /// Send an HTTP GET request and return the response.
  Future<AkariHttpResponse> sendRequest({
    required String url,
    required List<(String, String)> headers,
    required AkariRequestConfig config,
  });

  /// Send an HTTP request with specified method.
  Future<AkariHttpResponse> sendRequestWithMethod({
    required String url,
    required String method,
    required List<(String, String)> headers,
    required AkariRequestConfig config,
  });
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AkariClientPool>>
abstract class AkariClientPool implements RustOpaqueInterface {
  /// Get the current number of active clients.
  BigInt activeCount();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Create a new client pool connected to the remote proxy.
  ///
  /// * `host` - Remote proxy hostname
  /// * `port` - Remote proxy port
  /// * `psk` - Pre-shared key for authentication
  /// * `pool_size` - Maximum number of concurrent clients
  static Future<AkariClientPool> newInstance({
    required String host,
    required int port,
    required List<int> psk,
    required BigInt poolSize,
  }) => RustLib.instance.api.crateApiAkariClientAkariClientPoolNew(
    host: host,
    port: port,
    psk: psk,
    poolSize: poolSize,
  );

  /// Get the pool size (maximum number of concurrent clients).
  BigInt poolSize();

  /// Send an HTTP GET request and return the response.
  ///
  /// This method acquires a client from the pool, sends the request,
  /// and releases the client back to the pool.
  Future<AkariHttpResponse> sendRequest({
    required String url,
    required List<(String, String)> headers,
    required AkariRequestConfig config,
  });

  /// Send an HTTP request with specified method.
  Future<AkariHttpResponse> sendRequestWithMethod({
    required String url,
    required String method,
    required List<(String, String)> headers,
    required AkariRequestConfig config,
  });
}

/// HTTP response from the remote proxy.
@freezed
sealed class AkariHttpResponse with _$AkariHttpResponse {
  const factory AkariHttpResponse({
    required int statusCode,
    required List<(String, String)> headers,
    required Uint8List body,
    required AkariTransferStats stats,
  }) = _AkariHttpResponse;
}

/// Request configuration for AKARI-UDP client.
@freezed
sealed class AkariRequestConfig with _$AkariRequestConfig {
  const AkariRequestConfig._();
  const factory AkariRequestConfig({
    required BigInt timeoutMs,
    int? maxNackRounds,
    required int initialRequestRetries,
    required BigInt sockTimeoutMs,
    required BigInt firstSeqTimeoutMs,
    required bool aggTag,
    required bool shortId,
  }) = _AkariRequestConfig;
  static Future<AkariRequestConfig> default_() =>
      RustLib.instance.api.crateApiAkariClientAkariRequestConfigDefault();
}

/// Transfer statistics from a completed request.
@freezed
sealed class AkariTransferStats with _$AkariTransferStats {
  const factory AkariTransferStats({
    required BigInt bytesSent,
    required BigInt bytesReceived,
    required int nacksSent,
    required int requestRetries,
  }) = _AkariTransferStats;
}
