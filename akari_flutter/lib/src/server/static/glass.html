<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Liquid Glass Shader</title>
    <style>
      :root {
        color-scheme: dark;
        --text: #f6f2ea;
        --muted: rgba(246, 242, 234, 0.65);
        --accent: #f3c45c;
        font-family: "Inter", "SF Pro Display", "Yu Gothic", system-ui, sans-serif;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2rem;
        background: radial-gradient(circle at 20% 20%, rgba(243, 196, 92, 0.22), transparent 55%),
          radial-gradient(circle at 80% 0%, rgba(102, 102, 255, 0.2), transparent 52%),
          #04040a;
        color: var(--text);
        text-rendering: optimizeLegibility;
        transition: background 0.25s ease;
      }

      body::before {
        content: "";
        position: fixed;
        inset: 0;
        background-image: url("logo.png");
        background-position: center;
        background-repeat: no-repeat;
        background-size: clamp(520px, 72vmin, 1024px);
        filter: blur(1.5px);
        opacity: 0.24;
        transform: translateY(-2%);
        pointer-events: none;
        transition: filter 0.25s ease, opacity 0.25s ease;
        z-index: -2;
      }

      main {
        width: min(560px, 100%);
        text-align: center;
      }

      .liquid-glass {
        width: 100%;
        min-height: 360px;
        border-radius: 56px;
        padding: 2.3rem 2.5rem;
        position: relative;
        isolation: isolate;
        display: flex;
        align-items: flex-end;
        justify-content: flex-start;
        gap: 1.25rem;
        background: rgba(6, 8, 15, 0.65);
        border: 1px solid rgba(255, 255, 255, 0.2);
        box-shadow:
          inset 0 0 60px rgba(255, 255, 255, 0.05),
          0 20px 50px rgba(0, 0, 0, 0.55);
        backdrop-filter: blur(38px);
        -webkit-backdrop-filter: blur(38px);
        overflow: hidden;
      }

      .liquid-glass canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
      }

      .glass-copy {
        position: relative;
        z-index: 1;
        text-align: left;
        max-width: 280px;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .glass-copy .eyebrow {
        margin: 0;
        letter-spacing: 0.35rem;
        font-size: 0.72rem;
        text-transform: uppercase;
        color: var(--muted);
      }

      .glass-copy h1 {
        margin: 0;
        font-size: clamp(1.9rem, 2.4vw, 2.6rem);
        letter-spacing: 0.08em;
      }

      .glass-copy p {
        margin: 0;
        color: var(--muted);
        line-height: 1.6;
      }

      #sourceImage {
        display: none;
      }

      @media (max-width: 520px) {
        body {
          padding: 1.3rem;
        }

        .liquid-glass {
          padding: 1.6rem;
          min-height: 320px;
        }

        .glass-copy {
          max-width: none;
        }
      }
    </style>
  </head>
  <body>
    <main>
      <div class="liquid-glass" aria-label="Liquid glass shader preview">
        <canvas id="canvas"></canvas>
        <div class="glass-copy">
          <p class="eyebrow">Liquid glass</p>
          <h1>屈折する光とガラス</h1>
          <p>動的に揺らぐレンズ効果をパネル内に閉じ込めた、液体のようなガラス体験。</p>
        </div>
      </div>
    </main>
    <img
      id="sourceImage"
      crossorigin="anonymous"
      src="https://images.pexels.com/photos/268533/pexels-photo-268533.jpeg?cs=srgb&dl=pexels-pixabay-268533.jpg&fm=jpg"
      alt=""
    />
    <script id="fragShader" type="x-shader/x-fragment">
      precision mediump float;

      uniform vec3 iResolution;
      uniform float iTime;
      uniform vec4 iMouse;
      uniform sampler2D iChannel0;

      void mainImage(out vec4 fragColor, in vec2 fragCoord)
      {
        const float NUM_ZERO = 0.0;
        const float NUM_ONE = 1.0;
        const float NUM_HALF = 0.5;
        const float NUM_TWO = 2.0;
        const float POWER_EXPONENT = 6.0;
        const float MASK_MULTIPLIER_1 = 10000.0;
        const float MASK_MULTIPLIER_2 = 9500.0;
        const float MASK_MULTIPLIER_3 = 11000.0;
        const float LENS_MULTIPLIER = 5000.0;
        const float MASK_STRENGTH_1 = 8.0;
        const float MASK_STRENGTH_2 = 16.0;
        const float MASK_STRENGTH_3 = 2.0;
        const float MASK_THRESHOLD_1 = 0.95;
        const float MASK_THRESHOLD_2 = 0.9;
        const float MASK_THRESHOLD_3 = 1.5;
        const float SAMPLE_RANGE = 4.0;
        const float SAMPLE_OFFSET = 0.5;
        const float GRADIENT_RANGE = 0.2;
        const float GRADIENT_OFFSET = 0.1;
        const float GRADIENT_EXTREME = -1000.0;
        const float LIGHTING_INTENSITY = 0.3;

        vec2 uv = fragCoord / iResolution.xy;
        vec2 mouse = iMouse.xy;
        if (length(mouse) < NUM_ONE) {
          mouse = iResolution.xy / NUM_TWO;
        }
        vec2 m2 = (uv - mouse / iResolution.xy);

        float roundedBox = pow(abs(m2.x * iResolution.x / iResolution.y), POWER_EXPONENT) + pow(abs(m2.y), POWER_EXPONENT);
        float rb1 = clamp((NUM_ONE - roundedBox * MASK_MULTIPLIER_1) * MASK_STRENGTH_1, NUM_ZERO, NUM_ONE);
        float rb2 = clamp((MASK_THRESHOLD_1 - roundedBox * MASK_MULTIPLIER_2) * MASK_STRENGTH_2, NUM_ZERO, NUM_ONE) -
          clamp(pow(MASK_THRESHOLD_2 - roundedBox * MASK_MULTIPLIER_2, NUM_ONE) * MASK_STRENGTH_2, NUM_ZERO, NUM_ONE);
        float rb3 = clamp((MASK_THRESHOLD_3 - roundedBox * MASK_MULTIPLIER_3) * MASK_STRENGTH_3, NUM_ZERO, NUM_ONE) -
          clamp(pow(NUM_ONE - roundedBox * MASK_MULTIPLIER_3, NUM_ONE) * MASK_STRENGTH_3, NUM_ZERO, NUM_ONE);

        fragColor = vec4(NUM_ZERO);
        float transition = smoothstep(NUM_ZERO, NUM_ONE, rb1 + rb2);

        if (transition > NUM_ZERO) {
          vec2 lens = ((uv - NUM_HALF) * NUM_ONE * (NUM_ONE - roundedBox * LENS_MULTIPLIER) + NUM_HALF);
          float total = NUM_ZERO;
          for (float x = -SAMPLE_RANGE; x <= SAMPLE_RANGE; x++) {
            for (float y = -SAMPLE_RANGE; y <= SAMPLE_RANGE; y++) {
              vec2 offset = vec2(x, y) * SAMPLE_OFFSET / iResolution.xy;
              fragColor += texture2D(iChannel0, offset + lens);
              total += NUM_ONE;
            }
          }
          fragColor /= total;

          float gradient = clamp((clamp(m2.y, NUM_ZERO, GRADIENT_RANGE) + GRADIENT_OFFSET) / NUM_TWO, NUM_ZERO, NUM_ONE) +
            clamp((clamp(-m2.y, GRADIENT_EXTREME, GRADIENT_RANGE) * rb3 + GRADIENT_OFFSET) / NUM_TWO, NUM_ZERO, NUM_ONE);
          vec4 lighting = clamp(fragColor + vec4(rb1) * gradient + vec4(rb2) * LIGHTING_INTENSITY, NUM_ZERO, NUM_ONE);

          fragColor = mix(texture2D(iChannel0, uv), lighting, transition);
        } else {
          fragColor = texture2D(iChannel0, uv);
        }
      }

      void main() {
        mainImage(gl_FragColor, gl_FragCoord.xy);
      }
    </script>
    <script>
      const canvas = document.getElementById("canvas");
      const glassPanel = document.querySelector(".liquid-glass");
      const img = document.getElementById("sourceImage");
      const gl = canvas.getContext("webgl");

      const setCanvasSize = () => {
        const rect = glassPanel.getBoundingClientRect();
        const width = Math.max(1, Math.floor(rect.width));
        const height = Math.max(1, Math.floor(rect.height));
        if (canvas.width !== width || canvas.height !== height) {
          canvas.width = width;
          canvas.height = height;
        }
      };

      let mousePosition = [0, 0];

      const resetMousePosition = () => {
        mousePosition = [canvas.width / 2, canvas.height / 2];
      };

      const adjustLayout = () => {
        setCanvasSize();
        resetMousePosition();
      };

      adjustLayout();
      window.addEventListener("resize", adjustLayout);

      const updateMousePosition = (event) => {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = rect.height - (event.clientY - rect.top);
        mousePosition = [
          Math.max(0, Math.min(rect.width, x)),
          Math.max(0, Math.min(rect.height, y)),
        ];
      };

      canvas.addEventListener("mousemove", updateMousePosition);
      canvas.addEventListener("mouseleave", resetMousePosition);

      if (!gl) {
        console.error("WebGL がサポートされていません。");
      } else {
        const vsSource = `
          attribute vec2 position;
          void main() {
            gl_Position = vec4(position, 0.0, 1.0);
          }
        `;
        const fsSource = document.getElementById("fragShader").textContent;

        const createShader = (type, source) => {
          const shader = gl.createShader(type);
          gl.shaderSource(shader, source);
          gl.compileShader(shader);

          if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error("Shader error:", gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
          }
          return shader;
        };

        const vs = createShader(gl.VERTEX_SHADER, vsSource);
        const fs = createShader(gl.FRAGMENT_SHADER, fsSource);
        const program = gl.createProgram();

        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        gl.useProgram(program);

        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]),
          gl.STATIC_DRAW
        );

        const position = gl.getAttribLocation(program, "position");
        gl.enableVertexAttribArray(position);
        gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);

        const uniforms = {
          resolution: gl.getUniformLocation(program, "iResolution"),
          time: gl.getUniformLocation(program, "iTime"),
          mouse: gl.getUniformLocation(program, "iMouse"),
          texture: gl.getUniformLocation(program, "iChannel0"),
        };

        const texture = gl.createTexture();
        const setupTexture = () => {
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texImage2D(
            gl.TEXTURE_2D,
            0,
            gl.RGBA,
            gl.RGBA,
            gl.UNSIGNED_BYTE,
            img
          );
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        };

        if (img.complete) {
          setupTexture();
        } else {
          img.onload = setupTexture;
        }

        const startTime = performance.now();
        const render = () => {
          const currentTime = (performance.now() - startTime) / 1000;

          gl.viewport(0, 0, canvas.width, canvas.height);
          gl.clear(gl.COLOR_BUFFER_BIT);

          gl.uniform3f(uniforms.resolution, canvas.width, canvas.height, 1.0);
          gl.uniform1f(uniforms.time, currentTime);
          const [mouseX, mouseY] = mousePosition;
          gl.uniform4f(uniforms.mouse, mouseX, mouseY, 0, 0);

          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.uniform1i(uniforms.texture, 0);

          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
          requestAnimationFrame(render);
        };

        render();
      }
    </script>
  </body>
</html>
